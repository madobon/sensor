<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <style>
    body {
      max-width:50em;
      margin-right:auto;
      margin-left:auto;
      padding:1em;
      font-family:sans-serif;
    }
    .axis path,
    .axis line {
      fill:none;
      stroke:#000;
      shape-rendering:crispEdges;
    }
    .x.axis path {
      display:none;
    }
    .line {
      fill:none;
      stroke:#1572F9;
      stroke-width:1.5px;
    }
    text {
      font-size:10px;
    }
</style>
  <title>CC2650 SensorTag</title>
</head>
<body>
	<div id="svgchart" style="margin: 0 auto; width: 1040px;"></div>
  <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
  <script>

  (function(global){

    global.Chart = Chart;

    function Chart() {
       this._datas = [];
    }

    // グラフを描画するdivのidを指定する
    Chart.prototype.setSvg = function(wrapperId) {
      this._wrapperId =  wrapperId || 'svg-chart';
    }

    // 描画するデータをセット／更新
    Chart.prototype.setDatas = function(datas) {
      this._datas = datas;
    }

    // 初期化
    Chart.prototype.init = function() {

      // 描画範囲に関する変数
      var margin = {top: 20, right: 40, bottom: 20, left: 40},
          width = 720 - margin.left - margin.right,
          height = 480 - margin.top - margin.bottom;

      // x軸のスケール（時間）。レンジ(出力範囲)の指定
      var xScale = d3.time.scale()
                    .range([0, width]);

      // y軸のスケール（センサーデータの値）。レンジ(出力範囲)の指定
      var yScale = d3.scale.linear()
                    .range([height, 0]);

      // スケールを元にx軸の設定（入力値の範囲はまだ指定していない。データを受け取ってから指定する）
      var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom");

      // スケールを元にy軸の設定
      var yAxis = d3.svg.axis()
                  .scale(yScale)
                  .orient("left");

      // SVG要素の作成（attrとかはテンプレ）
      var svg = d3.select("#" + this._wrapperId).append("svg")
                .attr("class", "chart")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // 折れ線グラフの設定。xに時間、yにセンサーデータの値を設定。
      var line = d3.svg.line()
                  .x(function(d) {
                    // xスケールでマップされた時間を返す
                    return xScale(d.date);
                  })
                  .y(function(d) {
                    // yスケールでマップされたセンサーデータの値を返す
                    return yScale(d.value);
                  });


      // もろもろをメンバ変数に
      this._height = height;
      this._margin = margin;
      this._width = width;
      this._xScale = xScale;
      this._yScale = yScale;
      this._xAxis = xAxis;
      this._yAxis = yAxis;
      this._svg = svg;
      this._line = line;
    }


    // 最初の描画
    Chart.prototype.initialDraw = function() {

      var dataset = this._datas;

      // ドメイン（入力値の範囲）の設定、extentメソッドでdatasetの最小と最大を返す
      this._xScale.domain(d3.extent(dataset, function(d) { return d.date; }));
      this._yScale.domain(d3.extent(dataset, function(d) { return d.value; }));

      // x軸の描画
      this._svg.append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + this._height + ")")
              .call(this._xAxis)
              .append("text")
              .attr("x", this._width)
              .attr("dx", ".71em")
              .style("text-anchor", "end")
              .text("時間");

      // y軸の描画
      this._svg.append("g")
              .attr("class", "y axis")
              .call(this._yAxis)
              .append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 6)
              .attr("dy", ".71em")
              .style("text-anchor", "end")
              .text("値");

      // 折れ線の描画
      this._svg.append("path")
              .datum(dataset)
              .attr("class", "line")
              .attr("d", this._line);
    }


    // 更新した際の描画
    Chart.prototype.updateDraw = function() {

      var dataset = this._datas;

      // ドメイン（入力値の範囲）の更新
      this._xScale.domain(d3.extent(dataset, function(d) { return d.date; }));
      this._yScale.domain(d3.extent(dataset, function(d) { return d.value; }));

      // アニメーションしますよ、という宣言
      this._svg = d3.select("#" + this._wrapperId).transition();

      this._svg.select(".line")   // 折れ線を
          .duration(1000) // 1000msで
          .attr("d", this._line(dataset)); // （新しい）datasetに変化させる描画をアニメーション

      this._svg.select(".x.axis") // x軸を
          .duration(1000) // 1000msで
          .call(this._xAxis); // （domainの変更によって変化した）xAxisに変化させる描画をアニメーション

      this._svg.select(".y.axis") // y軸を
          .duration(1000) // 1000msで
          .call(this._yAxis); // （domainの変更によって変化した）yAxisに変化させる描画をアニメーション
    }

  }(window));

  var host = location.origin.replace(/^http/, 'ws')
  var ws = new WebSocket(host);

  var sensorData = [];

  var chart = new Chart();
      chart.setSvg("svgchart");
      chart.init();

  ws.onopen = function() {
    console.log('Connection opened.');
  };

  ws.onerror = function() {
    console.log('Error in connection');
  };

  ws.onclose = function() {
    console.log('Connection closed');
  };

  ws.onmessage = function (event) {
    var eventData = JSON.parse(event.data);

    switch (eventData.type) {
    case 'init':
      sensorData = eventData.sensordataset.map(function(obj){
        return {
          date: new Date(obj.date),
          value: +obj.temperature.toFixed(1)
        }
      });
      chart.setDatas(sensorData);
      chart.initialDraw();
      break;
    case 'update':
      sensorData.push({
        date: new Date(eventData.sensordata.date),
        value: +eventData.sensordata.temperature.toFixed(1),
      });
      sensorData.shift();
      chart.setDatas(sensorData);
      chart.updateDraw();
      break;
    default:
      throw Error("not defined");
    }

    console.table(sensorData);
  };
  </script>
</body>
</html>
