<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <style>
    body {
      max-width:50em;
      margin-right:auto;
      margin-left:auto;
      padding:1em;
      font-family:sans-serif;
    }
    .axis path,
    .axis line {
      fill:none;
      stroke:#000;
      shape-rendering:crispEdges;
    }
    .x.axis path {
      display:none;
    }
    .line {
      fill:none;
      stroke:#1572F9;
      stroke-width:1.5px;
    }
    text {
      font-size:10px;
    }
</style>
  <title>CC2650 SensorTag</title>
</head>
<body>
	<div id="svgchart" style="margin: 0 auto; width: 1040px;"></div>
  <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
  <script>

  (function(global){

    global.Chart = Chart;

    function Chart() {
       this.datas = [];
    }

    // グラフを描画するdivのidを指定する
    Chart.prototype.setSvg = function(wrapper_id) {
      this.wrapper_id =  wrapper_id || 'svg-chart';
    }

    // 描画するデータをセット／更新
    Chart.prototype.setDatas = function(datas) {
      this.datas = datas;
    }

    // 初期化
    Chart.prototype.init = function() {

      // 描画範囲に関する変数
      var margin = {top: 20, right: 20, bottom: 30, left: 40},
          width = 800 - margin.left - margin.right,
          height = 400 - margin.top - margin.bottom;

      // x軸のスケール（時間）。レンジ(出力範囲)の指定
      var xScale = d3.time.scale()
                    .range([0, width]);

      // y軸のスケール（センサーデータの値）。レンジ(出力範囲)の指定
      var yScale = d3.scale.linear()
                    .range([height, 0]);

      // スケールを元にx軸の設定（入力値の範囲はまだ指定していない。データを受け取ってから指定する）
      var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom");

      // スケールを元にy軸の設定
      var yAxis = d3.svg.axis()
                  .scale(yScale)
                  .orient("left");

      // SVG要素の作成（attrとかはテンプレ）
      var svg = d3.select("#" + this.wrapper_id).append("svg")
                .attr("class", "chart")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // 折れ線グラフの設定。xに時間、yにセンサーデータの値を設定。
      var line = d3.svg.line()
                  .x(function(d) {
                    // xスケールでマップされた時間を返す
                    return xScale(d.date);
                  })
                  .y(function(d) {
                    // yスケールでマップされたセンサーデータの値を返す
                    return yScale(d.value);
                  });


      // もろもろをメンバ変数に
      this.height = height;
      this.margin = margin;
      this.width = width;
      this.xScale = xScale;
      this.yScale = yScale;
      this.xAxis = xAxis;
      this.yAxis = yAxis;
      this.svg = svg;
      this.line = line;
    }


    // 最初の描画
    Chart.prototype.initialDraw = function() {

      var dataset = this.datas;

      // ドメイン（入力値の範囲）の設定、extentメソッドでdatasetの最小と最大を返す
      this.xScale.domain(d3.extent(dataset, function(d) { return d.date; }));
      this.yScale.domain(d3.extent(dataset, function(d) { return d.value; }));

      // x軸の描画
      this.svg.append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + this.height + ")")
              .call(this.xAxis)
              .append("text")
              .attr("x", this.width)
              .attr("dx", ".71em")
              .style("text-anchor", "end")
              .text("時間");

      // y軸の描画
      this.svg.append("g")
              .attr("class", "y axis")
              .call(this.yAxis)
              .append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 6)
              .attr("dy", ".71em")
              .style("text-anchor", "end")
              .text("値");

      // 折れ線の描画
      this.svg.append("path")
              .datum(dataset)
              .attr("class", "line")
              .attr("d", this.line);
    }


    // 更新した際の描画
    Chart.prototype.updateDraw = function() {

      var dataset = this.datas;

      // ドメイン（入力値の範囲）の更新
      this.xScale.domain(d3.extent(dataset, function(d) { return d.date; }));
      this.yScale.domain(d3.extent(dataset, function(d) { return d.value; }));

      // アニメーションしますよ、という宣言
      this.svg = d3.select("#" + this.wrapper_id).transition();

      this.svg.select(".line")   // 折れ線を
          .duration(750) // 750msで
          .attr("d", this.line(dataset)); // （新しい）datasetに変化させる描画をアニメーション

      this.svg.select(".x.axis") // x軸を
          .duration(750) // 750msで
          .call(this.xAxis); // （domainの変更によって変化した）xAxisに変化させる描画をアニメーション

      this.svg.select(".y.axis") // y軸を
          .duration(750) // 750msで
          .call(this.yAxis); // （domainの変更によって変化した）yAxisに変化させる描画をアニメーション
    }

  }(window));

  var host = location.origin.replace(/^http/, 'ws')
  var ws = new WebSocket(host);

  var dataset = [];

  var chart = new Chart();
      chart.setSvg("svgchart");
      chart.init();

  ws.onopen = function() {
    console.log('Connection opened.');
  };

  ws.onerror = function() {
    console.log('Error in connection');
  };

  ws.onclose = function() {
    console.log('Connection closed');
  };

  ws.onmessage = function (event) {
    var eventData = JSON.parse(event.data);

    switch (eventData.type) {
      case 'init':
        dataset = eventData.sensordataset.map(function(obj){
          return {
            date: obj.date,
            value: obj.temperature
          }
        });
        chart.setDatas(dataset);
        chart.initialDraw();
        break;
      case 'update':
        if (dataset.length > 30) {
          dataset.shift();
        }
        dataset.push({
          date: eventData.sensordata.date,
          value: eventData.sensordata.temperature,
        });
        chart.setDatas(dataset);
        chart.updateDraw();
        break;
      default:
    }
  };
  </script>
</body>
</html>
